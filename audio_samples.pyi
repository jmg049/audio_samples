from __future__ import annotations
import enum
from typing import Any

# High-performance audio processing library with Python bindings
# Generated stub file with integrated submodules for proper type checking

# Main Module Functions
# ====================
# List all available audio processing operations categorized by type.
def available_operations() -> Any: ...

def from_numpy(array: Any, sample_rate: float, copy: bool = ...) -> AudioSamples: ...

# Get information about the audio_samples library.
# # Returns
def info() -> Any: ...

def ones(length: Any, sample_rate: float, channels: int = ..., dtype: Any = ...) -> Any: ...

def zeros(length: Any, sample_rate: float, channels: int = ..., dtype: Any = ...) -> Any: ...

# Main Module Classes
# ==================
class AudioSamples:
    """
    Python wrapper for AudioSamples with efficient numpy integration.
    """
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    # Apply a digital filter (functional version).
    def apply_filter(self, coeffs: Any, mode: Any = ...) -> Any: ...
    # Apply a digital filter to the audio samples in-place.
    def apply_filter_(self, coeffs: Any, mode: Any = ...) -> Any: ...
    # Apply a windowing function (functional version).
    def apply_window(self, window: Any) -> Any: ...
    # Apply a windowing function to the audio samples in-place.
    def apply_window_(self, window: Any) -> Any: ...
    # Convert to different sample type with explicit dtype specification.
    def astype(self, dtype: Any, copy: bool = ...) -> Any: ...
    # Compute the autocorrelation function up to max_lag samples.
    def autocorrelation(self, max_lag: Any = ..., normalize: Any = ...) -> Any: ...
    # Adjust stereo balance between left and right channels.
    def balance(self, balance: Any) -> Any: ...
    # Adjust stereo balance between left and right channels in-place.
    def balance_(self, balance: Any) -> Any: ...
    # Apply a band-pass filter (functional version).
    def band_pass_filter(self, low_hz: Any, high_hz: Any) -> Any: ...
    # Apply a band-pass filter in-place.
    def band_pass_filter_(self, low_hz: Any, high_hz: Any) -> Any: ...
    # Apply Butterworth IIR filter (functional version).
    def butterworth_filter(self, cutoff: Any, order: Any = ..., filter_type: Any = ..., high_cutoff: Any = ...) -> Any: ...
    # Apply Butterworth IIR filter in-place.
    def butterworth_filter_(self, cutoff: Any, order: Any = ..., filter_type: Any = ..., high_cutoff: Any = ...) -> Any: ...
    def bytes_per_sample(self) -> Any: ...
    # Check if the audio data can be represented without loss in the target type.
    def can_convert_lossless(self, target_dtype: Any, tolerance: Any = ...) -> Any: ...
    channels: Any
    # Apply Chebyshev Type I IIR filter (functional version).
    def chebyshev_filter(self, cutoff: Any, order: Any = ..., ripple: Any = ..., filter_type: Any = ..., high_cutoff: Any = ...) -> Any: ...
    # Apply Chebyshev Type I IIR filter in-place.
    def chebyshev_filter_(self, cutoff: Any, order: Any = ..., ripple: Any = ..., filter_type: Any = ..., high_cutoff: Any = ...) -> Any: ...
    # Compute a chromagram (pitch class profile).
    def chroma(self, n_chroma: Any = ..., window_size: Any = ..., hop_size: Any = ...) -> Any: ...
    # Clip audio samples to the specified range (functional version).
    def clip(self, min_val: Any, max_val: Any) -> Any: ...
    # Clip audio samples to the specified range in-place.
    def clip_(self, min_val: Any, max_val: Any) -> Any: ...
    # Apply dynamic range compression (functional version).
    def compress(self, threshold: Any = ..., ratio: Any = ..., attack: Any = ..., release: Any = ..., knee: Any = ..., knee_width: Any = ..., makeup_gain: Any = ...) -> Any: ...
    # Apply dynamic range compression in-place.
    def compress_(self, threshold: Any = ..., ratio: Any = ..., attack: Any = ..., release: Any = ..., knee: Any = ..., knee_width: Any = ..., makeup_gain: Any = ...) -> Any: ...
    # Concatenate multiple audio segments into one.
    def concatenate(self, segments: Any, axis: Any = ...) -> Any: ...
    # Get information about precision loss for a given conversion.
    def conversion_info(self, target_dtype: Any) -> Any: ...
    # Create a copy of the AudioSamples object.
    def copy(self) -> AudioSamples: ...
    # Compute cross-correlation with another audio signal.
    def cross_correlation(self, other: AudioSamples, max_lag: Any = ..., normalize: Any = ...) -> Any: ...
    # Cross-fade between two audio sources.
    def crossfade(self, audio1: Any, audio2: Any, duration: Any, curve: Any = ..., offset: Any = ...) -> Any: ...
    dtype: Any
    duration: Any
    # Extract a specific channel as mono audio.
    def extract_channel(self, channel_index: Any) -> Any: ...
    # Apply fade-in envelope (functional version).
    def fade_in(self, duration: Any, curve: Any = ...) -> Any: ...
    # Apply fade-in envelope in-place.
    def fade_in_(self, duration: Any, curve: Any = ...) -> Any: ...
    # Apply fade-out envelope (functional version).
    def fade_out(self, duration: Any, curve: Any = ...) -> Any: ...
    # Apply fade-out envelope in-place.
    def fade_out_(self, duration: Any, curve: Any = ...) -> Any: ...
    # Compute the Fast Fourier Transform of the audio samples.
    def fft(self, n: Any = ..., axis: Any = ...) -> Any: ...
    # Compute a gammatone filter bank spectrogram.
    def gammatone_spectrogram(self, n_filters: Any = ..., fmin: Any = ..., fmax: Any = ..., window_size: Any = ..., hop_size: Any = ...) -> Any: ...
    # Apply a high-pass filter (functional version).
    def high_pass_filter(self, cutoff_hz: Any) -> Any: ...
    # Apply a high-pass filter in-place.
    def high_pass_filter_(self, cutoff_hz: Any) -> Any: ...
    # Compute the inverse Fast Fourier Transform from frequency domain.
    def ifft(self, spectrum: Any) -> Any: ...
    # Compute the inverse Short-Time Fourier Transform (ISTFT).
    def istft(self, stft_data: Any, hop_size: Any = ..., window: Any = ...) -> Any: ...
    length: Any
    # Apply brick-wall limiting (functional version).
    def limit(self, ceiling: Any = ..., release: Any = ..., lookahead: Any = ...) -> Any: ...
    # Apply brick-wall limiting in-place.
    def limit_(self, ceiling: Any = ..., release: Any = ..., lookahead: Any = ...) -> Any: ...
    # Apply a low-pass filter (functional version).
    def low_pass_filter(self, cutoff_hz: Any) -> Any: ...
    # Apply a low-pass filter in-place.
    def low_pass_filter_(self, cutoff_hz: Any) -> Any: ...
    # Return the maximum value in the audio samples.
    def max(self) -> Any: ...
    # Compute a mel-scale spectrogram.
    def mel_spectrogram(self, n_mels: Any = ..., fmin: Any = ..., fmax: Any = ..., window_size: Any = ..., hop_size: Any = ...) -> Any: ...
    # Compute Mel-Frequency Cepstral Coefficients (MFCCs).
    def mfcc(self, n_mfcc: Any = ..., n_mels: Any = ..., fmin: Any = ..., fmax: Any = ..., window_size: Any = ..., hop_size: Any = ...) -> Any: ...
    # Return the minimum value in the audio samples.
    def min(self) -> Any: ...
    # Mix multiple audio sources together.
    def mix(self, sources: Any, weights: Any = ..., normalize: Any = ...) -> Any: ...
    # Apply μ-law compression (functional version).
    def mu_compress(self, mu: Any = ...) -> Any: ...
    # Apply μ-law compression to the audio samples in-place.
    def mu_compress_(self, mu: Any = ...) -> Any: ...
    # Apply μ-law expansion (functional version).
    def mu_expand(self, mu: Any = ...) -> Any: ...
    # Apply μ-law expansion (decompression) to the audio samples in-place.
    def mu_expand_(self, mu: Any = ...) -> Any: ...
    # Normalize audio samples using the specified method (functional version).
    def normalize(self, method: Any, min_val: Any = ..., max_val: Any = ...) -> AudioSamples: ...
    # Normalize audio samples in-place using the specified method.
    def normalize_(self, method: Any, min_val: Any = ..., max_val: Any = ...) -> Any: ...
    # Add padding/silence to the beginning and/or end of the audio.
    def pad(self, start_sec: Any, end_sec: Any, value: Any = ...) -> Any: ...
    # Pan stereo audio left or right.
    def pan(self, position: Any) -> Any: ...
    # Pan stereo audio left or right in-place.
    def pan_(self, position: Any) -> Any: ...
    # Apply parametric equalization (functional version).
    def parametric_eq(self, bands: Any, output_gain: Any = ...) -> Any: ...
    # Apply parametric equalization in-place.
    def parametric_eq_(self, bands: Any, output_gain: Any = ...) -> Any: ...
    # Return the peak (maximum absolute value) in the audio samples.
    def peak(self) -> Any: ...
    # Compute the power spectral density using Welch's method.
    def power_spectral_density(self, window_size: Any = ..., overlap: Any = ..., window: Any = ...) -> Any: ...
    # Remove DC offset (functional version).
    def remove_dc_offset(self) -> Any: ...
    # Remove DC offset by subtracting the mean value in-place.
    def remove_dc_offset_(self) -> Any: ...
    # Repeat the audio signal a specified number of times.
    def repeat(self, count: Any) -> Any: ...
    def resample(self, target_sample_rate: Any, quality: Any = ...) -> Any: ...
    def resample_by_ratio(self, ratio: Any, quality: Any = ...) -> Any: ...
    # Reverse the order of audio samples.
    def reverse(self) -> Any: ...
    # Reverse the order of audio samples in-place.
    def reverse_(self) -> Any: ...
    # Compute the Root Mean Square (RMS) of the audio samples.
    def rms(self) -> Any: ...
    sample_rate: Any
    def sample_type(self) -> Any: ...
    # Scale all audio samples by a constant factor (functional version).
    def scale(self, factor: Any) -> AudioSamples: ...
    # Scale all audio samples by a constant factor in-place.
    def scale_(self, factor: Any) -> Any: ...
    shape: Any
    size: Any
    # Compute the spectral centroid (brightness measure).
    def spectral_centroid(self) -> Any: ...
    # Compute spectral rolloff frequency.
    def spectral_rolloff(self, rolloff_percent: Any = ...) -> Any: ...
    # Compute a spectrogram of the audio signal.
    def spectrogram(self, window_size: Any = ..., hop_size: Any = ..., window: Any = ..., scale: Any = ..., power: Any = ...) -> Any: ...
    # Split audio into segments of specified duration.
    def split(self, segment_duration: Any, overlap: Any = ...) -> Any: ...
    # Compute the standard deviation of the audio samples.
    def std_dev(self) -> Any: ...
    # Compute the Short-Time Fourier Transform (STFT).
    def stft(self, window_size: Any = ..., hop_size: Any = ..., window: Any = ...) -> Any: ...
    # Swap left and right channels (for stereo audio).
    def swap_channels(self) -> Any: ...
    # Swap left and right channels in-place (for stereo audio).
    def swap_channels_(self) -> Any: ...
    # Test method to verify methods can be added.
    def test_method(self) -> Any: ...
    # Convert to single precision floating-point format (f32).
    def to_f32(self) -> Any: ...
    # Convert to the highest precision floating-point format (f64).
    def to_f64(self) -> Any: ...
    # Convert to 16-bit integer format (CD quality).
    def to_i16(self) -> Any: ...
    # Convert to 32-bit integer format.
    def to_i32(self) -> Any: ...
    # Convert to mono by mixing all channels with equal weights.
    def to_mono(self) -> Any: ...
    def to_numpy(self, dtype: Any = ..., copy: bool = ...) -> Any: ...
    # Convert mono audio to stereo by duplicating the channel.
    def to_stereo(self) -> Any: ...
    # Extract a segment of audio between start and end times.
    def trim(self, start_sec: Any, end_sec: Any, copy: bool = ...) -> Any: ...
    # Remove silence from the beginning and end of the audio.
    def trim_silence(self, threshold: Any, min_duration: Any = ...) -> Any: ...
    # Compute the statistical variance of the audio samples.
    def variance(self) -> Any: ...
    # Create a view of the audio data as a different type without conversion.
    def view_as(self, target_dtype: Any) -> Any: ...
    # Compute the zero crossing rate (crossings per second).
    def zero_crossing_rate(self) -> Any: ...
    # Count the number of zero crossings in the audio signal.
    def zero_crossings(self) -> Any: ...

# Main Module Constants
# ====================
SUPPORTED_DTYPES: Any
audio_samples: Any

# Submodules
# ==========
# These are accessible as audio_samples.streaming and audio_samples.playback

class streaming:
    """Streaming submodule for audio streaming capabilities"""

    class AudioFormatInfo:
        """
        Python wrapper for AudioFormatInfo
        """
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        bits_per_sample: Any
        channels: Any
        # Create format info for f32 samples
        def f32(self, sample_rate: float, channels: int) -> Any: ...
        # Create format info for i16 samples
        def i16(self, sample_rate: float, channels: int) -> Any: ...
        # Check if this format is compatible with another
        def is_compatible(self, other: AudioSamples) -> bool: ...
        is_float: Any
        is_signed: Any
        sample_format: Any
        sample_rate: Any

    class GeneratorSource:
        """
        Python wrapper for GeneratorSource
        """
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        # Create a chirp generator
        def chirp(self, start_freq: float, end_freq: float, duration_sec: float, sample_rate: float, channels: int) -> Any: ...
        # Get format information for this generator
        def format_info(self) -> Any: ...
        # Check if the source is still active
        def is_active(self) -> bool: ...
        # Generate the next chunk of audio data (simplified sync version)
        def next_chunk(self) -> Any: ...
        # Create a silence generator
        def silence(self, sample_rate: float, channels: int) -> Any: ...
        # Create a sine wave generator
        def sine(self, frequency: float, sample_rate: float, channels: int) -> Any: ...
        # Create a white noise generator
        def white_noise(self, sample_rate: float, channels: int) -> Any: ...

    class StreamConfig:
        """
        Python wrapper for StreamConfig
        """
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        auto_recovery: Any
        buffer_size: Any
        # Create configuration optimized for high-quality streaming
        def high_quality(self) -> Any: ...
        # Create configuration optimized for low-latency applications
        def low_latency(self) -> Any: ...
        # Create configuration for network streaming with error tolerance
        def network_streaming(self) -> Any: ...

    def chirp_generator(start_freq: float, end_freq: float, duration_sec: float, sample_rate: float, channels: int) -> GeneratorSource: ...

    def noise_generator(sample_rate: float, channels: int) -> GeneratorSource: ...

    def silence_generator(sample_rate: float, channels: int) -> GeneratorSource: ...

    # Factory functions for convenience
    def sine_generator(frequency: float, sample_rate: float, channels: int) -> GeneratorSource: ...

class playback:
    """Playback submodule for audio playback capabilities"""

    class AudioPlayer:
        """
        Python wrapper for SimpleAudioPlayer
        """
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        # Check if looping is enabled
        # # Returns
        def is_loop_enabled(self) -> bool: ...
        # Check if currently playing
        # # Returns
        def is_playing(self) -> bool: ...
        def load_audio(self, audio: AudioSamples) -> AudioSamples: ...
        # Pause playback
        # # Examples
        def pause(self) -> None: ...
        # Start playback
        # # Examples
        def play(self) -> None: ...
        # Convenience method to play audio from start
        # # Examples
        def play_from_start(self) -> Any: ...
        # Get current position as duration in seconds
        # # Returns
        def position(self) -> float: ...
        # Get current position in samples
        # # Returns
        def position_samples(self) -> int: ...
        # Seek to a specific position
        # # Arguments
        def seek(self, position_sec: float) -> None: ...
        # Enable or disable looping
        # # Arguments
        def set_loop(self, enable: bool) -> None: ...
        # Set playback volume (0.0 to 1.0)
        # # Arguments
        def set_volume(self, volume: float) -> None: ...
        # Get current playback state
        # # Returns
        def state(self) -> Any: ...
        # Stop playback and reset position to beginning
        # # Examples
        def stop(self) -> None: ...
        # Convenience method to toggle play/pause
        # # Examples
        def toggle_playback(self) -> Any: ...
        # Get current volume level (0.0 to 1.0)
        # # Returns
        def volume(self) -> float: ...

    PAUSED: Any

    PLAYING: Any

    class PlaybackState:
        """
        Python wrapper for SimplePlaybackState
        """
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
        PAUSED: Any
        PLAYING: Any
        STOPPED: Any
        # Check if currently paused
        def is_paused(self) -> bool: ...
        # Check if currently playing
        def is_playing(self) -> bool: ...
        # Check if currently stopped
        def is_stopped(self) -> bool: ...

    STOPPED: Any

    # Create a new audio player
    # # Returns
    def create_player() -> AudioPlayer: ...

    def play_audio(audio: AudioSamples, volume: float = ..., loop_audio: bool = ...) -> Any: ...
